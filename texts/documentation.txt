#===============#
#== Objective ==#
#===============#

One of the most frustrating things about reading a webcomic or other serialized story is when a character or location or item re-appears after not having been mentioned for months or years and suddenly the reader is left either digging through source material to figure out who or what is being discussed, or (more often) simply accepting that they will be confused with the story for a bit, but hoping that context clues further on will remind them of what's going on. Serialized web stories almost always have a "characters" page - this can fill in the gaps to some extent, but almost always it's designed to be as spoiler free as possible, which means that the information you're looking for is rarely ever there.

"Sure the prince of the kingdom has a mysterious past, but the details of that mysterious past were discussed a few hundred pages back and why should I have to dig through history of the story to find the specific twenty pages that I need to re-read If those details colud be summed up in an easily accessable paragraph or two?!"

The goal of this project is to create a "characters" page that updates as the story moves forward. It's designed specifically to determine what page is "current" based on the referrer URI (what page linked to it) and not show any data from after that point. Readers can browse backward through when a certain character or item's description has changed and be linked to the page within the source content relevant to that change. To be clear - the goal isn't to absolutely prevent users from spoiling content for themselves (because they're users - if they really want to, they'll find a way) but rather to offer them details relevant and up-to-date relative to their current position in the story.

#=====================#
#== Getting Started ==#
#=====================#

Note: This project does not include any process for uploading files to the server, so if you don't have a way to accomplish that, maybe this project is not right for you.

1) Upload all of the files for this project to the server. Ensure that they have the correct permissions, etc.
2) Create a database and two database users for this project. See the "Mysql Users" section below for details regarding the two users.
3) Edit the includes/config.php file on the server to include the mysql username and password as well as other relevant bits.
4) Navigate to the initialize.php file and enter the username and password for the admin user. This will create the necessary tables within the database.
5) Navigate to the import.php file and enter the username and password for the admin user. Add content (see the details below on how keywords should be used).
6) That's it - You're up and running!

#==========================#
#== Database Information ==#
#==========================#

Table1 (cp_names): two columns - compares the URI to a post number
        a URI
        a page number (not necessarily incrimenting)
Table2 (cp_contents): four columns - a list of content that we'll be working from for each page
        a number that corralates to table1
        text describing categories and content items for those categories
	a type ("page", "list", or "block")
	a name ("page" and "list" types are automatically named "cp_page_con" and "cp_list_con", respectively)
Table3 (cp_items): five columns - the details for an item
        the name of a content item
        the page number
        text describing that item.
	The next page that that item is updated on
	The previous page that that item is updated on
Table4 (cp_styles): four columns - styles and layouts
        the type of style it is ("full", "section", "single", "block")
        the name of the style
        the page number
        text describing that style
Table5 (cp_types): two columns - what type of item each item is
        an item name
        the type of item it is (e.g. "character", "setting")
Table6 (cp_documents): two columns - single webpages, such as a main page or a "contacts" page
	The URI that the page should be located at (relative to the base uri)
	Text describing what will be shown there.

The commands to create these databases look like this:

CREATE TABLE IF NOT EXISTS cp_names ( URI VARCHAR(100) PRIMARY KEY, Page FLOAT(8.2) );
CREATE TABLE IF NOT EXISTS cp_contents ( Page FLOAT(8.2) PRIMARY KEY, Content MEDIUMTEXT );
CREATE TABLE IF NOT EXISTS cp_items ( Name VARCHAR(100), Page FLOAT(8.2), Description LONGTEXT, Next FLOAT(8.2), Previous FLOAT(8.2), PRIMARY KEY ( Name, Page ) );
CREATE TABLE IF NOT EXISTS cp_styles ( Type TINYTEXT, Name VARCHAR(100), Page FLOAT(8.2), Description LONGTEXT, PRIMARY KEY ( Name, Page ) );
CREATE TABLE IF NOT EXISTS cp_types ( Name VARCHAR(100) PRIMARY KEY, Type TINYTEXT );
CREATE TABLE IF NOT EXISTS cp_documents ( URI VARCHAR(100) PRIMARY KEY, Description LONGTEXT );

#=================#
#== Mysql Users ==#
#=================#

The script is designed to be used with two mysql users - one that only has SELECT privileges and one with all privileges in relation to the database created. The creation statements should look something like this:

CREATE USER 'cp_user'@'localhost' IDENTIFIED BY 'password123';
GRANT SELECT ON cp_database.* TO 'cp_user'@'localhost';
CREATE USER 'cp_user2'@'localhost' IDENTIFIED BY 'password456';
GRANT ALL PRIVILEGES ON cp_database.* TO 'cp_user2'@'localhost';
FLUSH PRIVILEGES;

The idea is that the config file will only have the username and password of the less privileged user, while the credentials for the more privileged user will not be stored on the server. This significantly reduces the likelihood of a malicious user modifying database contents without the owner's knowledge or permission.

#===================#
#== General Rules ==#
#===================#

* All styles and items MUST have internal names without spaces or tabs, given that the parsing is done based on whitespace.

#=======================#
#== Config Directives ==#
#=======================#

* DB_NAME - The name of the mysql database that you're connecting to
* DB_USER - The mysql user that you're connecting to the database with (Note, this should be the user with lesser permissions)
* DB_PASSWORD - The password of the mysql user that you're connecting with
* DB_HOST - This will almost always be "localhost". 
* REFERER_BASE - Assuming that the source is linking to this page, what's the base URL of the referrer for those requests? So for example, if a standard page from the sounce would have the URL "https://example.com/posts/2014-11-25/10", the REFERER_BASE should likely be "example.com/posts/"
* REFERER_MAIN - The full URL of the main page of the source site. So with the above example, probably "example.com/"
* PROTOCOL - What is the protocol that the referrer uses? Either "http" or "https"
* BASE_URI - The base URI for THIS site (not the source site). Examples: If you have this site installed at "https://www.characterpage.com/", then the BASE_URI needs to be "/"; if you have it installed at "https://www.characterpage.com/subdirectories/are/great/", the BASE_URI needs to be "/subdirectories/are/great/"
* TABLE_PREFIX - You usually won't need to chane this from "cp_", but really, this can be what ever you want.
* PAGE_DIR - The directory that you want indvidual pages to be referenced at. So, if you want the character page for pagge 40 of the source to be located at "https://www.characterpage.com/pages/40", you will want PAGE_DIR to be set as "pages/". In theory, this doesn't have to be a directory, for example, if you want the url to be "https://www.characterpage.com/page_40", you could set PAGE_DIR to "page_".

#=====================#
#== Types of Styles ==#
#=====================#

* full - This is the style that full character pages are built from. 
* section - This style focuses on individual sections of content in which items will be listed. So for example, a full page might have sections for "characters" and locations"; section styles will define what frames each of the individual items in those sections.
* single - This style is for pages displayed within the iframe showing only a single item. Think of them as a cross between full and section.
* block - This style is for blocks of content that are not expected to contain other items. For example, they might be used for a header or footer. These are called with the "block" command keyword. Note that there are a number of command keywords that can be used within block styles, but depending on where they're placed, they may not necessarily have the desired effect.
* item - Technically this is not a style. Items contain information about a specific item (relevant to a specific page) as well as text regarding that item.
* document - Also technically not a style. Documentss have their own unique URI on the site. The site will fail to behave as intended if there is not at least one document (the main page of the site) defined with URI "/".

#======================#
#== Command Keywords ==#
#======================#

Styles and, to some extent, items are created with HTML code. in order to get them to behave in the desired manner, this code is mixed in with command keywords that help determine what portions of the HTML should be output and in what way. All command keywords are prefaced by the string ">>>" with some amount of whitespace on either end. Other than the whitespace and the arguments descrived below nothing can come before or after them on the same line. 

Regular command keywords:
* >>> var [VARIABLE NAME] - a variable to be interpreted by the script
* >>> comment [TEXT] - a comment that won't be interpreted y the parser
* >>> link [ITEM NAME] - an item name to convert into a URL
* >>> ilink [ITEM NAME] [TEXT] - Convert this to a link that will be opened in the iframe
* >>> plink [TEXT] - Convert this to a link for the previous version of the current item
* >>> nlink [TEXT] - Convert this to a link for the next version of the current item (only on single item view)
* >>> content - the next level of content in the "full"->"section"->"item" chain, or the iframe for "full" styles that single pages will go into. (cannot be used in "block" styles)
* >>> block [STYLE NAME] - used to call a block style.
* >>> no_new_line - prevents the output from the previous line ending in a new line character. Useful for some spacing weirdness
* >>> set [NUMBER] [TEXT] - allows a usert to associate a number with a string and then later use the "SET" variable to recall that string.
* >>> constant [NUMBER] [TEXT] - sets constant - only set the first time that it's referenced, other instances are ignored. This allows some flexibility for using "full" styles on documents. see the "CONSTANT" variable below.

Indicate start or end positions
* >>> repeat ["start" OR "end"] - (only in "section" and "full") Everything in between repeats for each section or item (if multiple starts are present before an end, they will be used in sequence and loop until all sections or items have been used) (cannot be used in "block" styles)
* >>> not_first ["start" OR "end"] - (only in "section", "full", and "block") Apply this to all items but the first
* >>> not_last ["start" OR "end"] - (only in  "section", "full", and "block") Apply this to all items but the last
* >>> is_first ["start" OR "end"] - (only in "section", "full", and "block") Apply this only to the first item
* >>> is_last ["start" OR "end"] - (only in  "section", "full", and "block") Apply this only to the last item
* >>> is_prev ["start" OR "end"] - (only in "single", "section", and "block") data that only appears if there's a previous item
* >>> is_next ["start" OR "end"] - (only in "single" and "block") data that only appears if there's a next item
* >>> no_prev ["start" OR "end"] - (only in "single", "section", and "block") data that only appears if there is no previous item
* >>> no_next ["start" OR "end"] - (only in "single" and "block") data that only appears if there is no next item
* >>> is_int_prev ["start" OR "end"] - (only in "full" or "block) data that only appears if there's a previous internal page
* >>> is_int_next ["start" OR "end"] - (only in "full" or "block) data that only appears if there's a next internal page
* >>> not_int_prev ["start" OR "end"] - (only in "full" or "block) data that only appears if there's no previous internal page
* >>> not_int_next ["start" OR "end"] - (only in "full" or "block) data that only appears if there's no next internal page
* >>> head ["start" OR "end"] - indicates a section that goes into the header
* >>> iframe ["start" OR "end"] - indicates a section that goes into the div that surrounds the iframe

Special data for items:
* >>> disp_name - (only for items) The display name of the item
* >>> disp_image - (only for items) The image url for an item
* >>> item_data - (only for items) a varaible that can be used to store data about the item. Multiple of these can be used; they will be stored in an array
* >>> description ["start" OR "end"] - indicates the description for an item

Special data for "full" styles:
* >>> single [STYLE NAME] - declare the single image style that should be used for the iframe

Special data for "documents":
* >>> style [FULL STYLE NAME] [PAGE NUMBER] - When defining documents, if this is used, the style named will be output. Everything after this point within the document definition will be output with the "content" command keyword.

Plain HTML and other information:
* Anything that needs to be parsed as plain html doesn't need to be preceeded with anything
* In "full" styles, the "content" call is where the script will request the content for the upcoming section, so if you plan to have sections, "content" NEEDS to be present.
* In "section" styles, the "repeat" call is when the script will request the content for the next item, so if you plan to have items, "repeat" NEEDS to be present - even if you know that there will only be one item.

Note: Other than the following exceptions, all lines beginning with ">>>" will be surrounded by new-line characters in the output html:
* var
* link

#==================================#
#== Command Keywords for Content ==#
#==================================#

Content is handled by a different parser than items and styles (though the headers and footers within content are an exception to this). Here are the special command keywords for parsing content:

Special data for "content":
* >>> style [FULL STYLE NAME] - the style for the page (should be declared before any styles or items)
* >>> s_name [NAME ]- the name of the upcoming section (should be declared before the style) (There's no reason that this cannot contain any length of text or html)
* >>> s_style [SECTION STYLE NAME] - the style of the upcoming section
* >>> item [ITME NAME] - an item within the section

#==========================#
#== Declaration Keywords ==#
#==========================#

The script can import the contents of text files into the database. For this process, what kind of internal object (style, name, content, item, or type) as well as some other data will need to be specified. Declaration keywords are used to provide this information. All declaration keywords are prefaced by the string ">>>>>" with some amount of whitespace on either end. Other than the whitespace and the arguments descrived below nothing can come before or after them on the same line.

Creation:
* >>>>> declare name [URL] [PAGE]
* >>>>> declare content [PAGE] [TYPE ("page", "list", or "block")] [NAME (only necessary for block, otherwise will be ignored)] (after this, a new line followed by the desired content
* >>>>> declare style [NAME] [PAGE] [TYPE] (after this, a new line followed by the desired content)
* >>>>> declare item [NAME] [PAGE] (after this, a new line followed by the desired content)
* >>>>> declare type [NAME] [TYPE]
* >>>>> declare document [URI] (after this, a new line followed by the desired content)

Deletion:
* >>>>> delete name [URL]
* >>>>> delete content [PAGE] [NAME (only necessary for block, otherwise will be ignored)]
* >>>>> delete style [NAME] [PAGE]
* >>>>> delete item [NAME] [PAGE]
* >>>>> delete type [NAME]
* >>>>> delete document [URI]

Note: for "content", "cp_page_con" and "cp_list_con" are exempt from being used as names, as they will be the names populated for non block content. Inversely, when ever deleting "page" or "list" content types, you will need to specify "cp_page_con" or "cp_list_con" as appropriate for the name

#========================#
#== Internal Variables ==#
#========================#

These are variables that can be used with the command keyword "var":

* ITEM_NAME - The name used internally to reference this item
* DISP_NAME - The display name of an item (note, there's no rreason why this cannot contain html)
* IMAGE - the image url for an item. These should be relative to the directory where index.php is located.
* ITEM_DATA [NUMBER (starting with 1)] - Other data for the item, stored as an array. So, for example, if you want to have a variable for the age of characters.
* SECTION_NAME - the display name of a section (note, there's no rreason why this cannot contain html)
* SOURCE_URL - the URL of the source page that this page is referencing
* MAIN_EXT_URL - The URL of the main page of the source
* MAIN_URL - the URL for the main page of this site (not the source site)
* SECT_NUM - the number of the current section (counting starts at zero)
* ITEM_NUM - The number of the current item in the current section (counting starts at zero)
* NEXT_INT_PAGE - (Not available for single styles) the URL of the next internal page
* PREV_INT_PAGE - (Not available for single styles) the URL of the previous internal page
* SET [NUMBER] - a variable set by the user using the "set" command keyword
* CONSTANT [NUMBER] - a constant set by the user using the "constant" command keyword. Once a constant is set, further attempts to change it will fail silently.

#===================#
#== Project Files ==#
#===================#

Files that are included within the project:

* index.php - Calls the other files for the script
* initialize.php - creates the necessary mysql tables (assuming that there is already a mysql user and database, and that the config file is filled out)
* import.php - A page that allows the user to import content into the database
* export.php - Outputs the text for all of the items, types, names, contents, and styles within the database.
* includes/config.php - Includes the configuration to connect to the database as well as specifics about the site in question
* includes/parse.php - Includes the functions necessaey to parse the contents, items, and styles
* includes/url.php - Parses the url and other data to determine what content needs to be loaded
* includes/full.php - Loads a full page relative to a post from the source page
* includes/connect.php - connects to mysql
* includes/single.php - Loads a siingle page view
* includes/js_top_full.txt - text that will be used to begin the full page view pages
* includes/js_bottom_full.txt - additional text for the full page view pages containing the javascript that makes the links work
* includes/parse2.php - Includes the functions necessaary to parse database content
* includes/document.php - The processes necessary for loading a document.

#===============================#
#== Internally Generated HTML ==#
#===============================#

There are four major pieces of HTML that are generated by the code within the project. All other HTML will need to be within styles and items.

* The following tags will be added programatically <html>, <head>, </head>, </body>, </html>. Note that the opening <body> tag is expected to be within styles.
* The script will create the "next" and "previous" links for items based on command keywords within style (more information below)
* The script will create the iframe element for single item pages based on the "content" command keyword within "iframe start" and "iframe end" command keywords within the style (more information below)
* The script will output initial css and javascript content based on the text within the files js_top_full.txt and js_bottom_full.txt

#=====================#
#== Regarding Links ==#
#=====================#

Any links generated by this project within the full page view will have the html class "cp_link". They will be presented in the following format:

	<a class="cp_link" href="#" src="" onclick="fn_open_link(this);return false;">link text</a>

where the value for "src" will be populated with the URL of the single item view. They will still have the same class within the single item view, but they will look like this instead:

	<a class="cp_link" href="">link text</a>

where the "href" attribute will be populated with the URL.

#==========================#
#== Regarding the Iframe ==#
#==========================#

The iframe containing the single item view will be put in place with the ">>> content" indicator after beginning an ">>> iframe start" block. It will have the id "cp_single" and will be in this format:

	<iframe id="cp_single" src=""></iframe>

and the "src" attribute will be populated by javascript as needed.






