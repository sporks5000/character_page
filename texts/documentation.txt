#===============#
#== Objective ==#
#===============#

One of the most frustrating things about reading a webcomic or other serialized story is when a character or location or item re-appears after not having been mentioned for months or years and suddenly the reader is left either digging through source material to figure out who or what is being discussed, or (more often) simply accepting that they will be confused with the story for a bit, but hoping that context cludes further on will remind them of what's going on. Serialized web stories almost always have a "characters" page - this can fill in the gaps to some extent, but almost always it's designed to be as spoiler free as possible, which means that the information you're looking for is rarely ever there.

The goal of this project is to create a "characters" page that updates as the story moves forward. It's designed specifically to determine what page is "current" based on the referrer URI (what page linked to it) and not show any data from after that point. Readers can browse backward through when a certain character or item's description has changed and be linked to the page within the source content relevant to that change. To be clear - the goal isn't to absolutely prevent users from spoiling content for themselves (because they're users - if they really want to, they'll find a way) but rather to offer them details relevant and up-to-date relative to their current position in the story.

#=====================#
#== Getting Started ==#
#=====================#

Note: This project does not include any process for uploading files to the server, so if you don't have a way to accomplish that, maybe this project is not right for you.

1) Upload all of the files for this project to the server. Ensure that they have the correct permissions, etc.
2) Create a database and two database users for this project. See the "Mysql Users" section below for details regarding the two users.
3) Edit the includes/config.php file on the server to include the mysql username and password as well as other relevant bits.
4) Navigate to the initialize.php file and enter the username and password for the admin user. This will create the necessary tables within the database.
5) Navigate to the import.php file and enter the username and password for the admin user. Add content for the page.
6) That's it - You're up and running!

#==========================#
#== Database Information ==#
#==========================#

Table1 (cp_names): two columns - compares the URI to a post number
        a URI
        a page number (not necessarily incrimenting)
Table2 (cp_contents): two columns - the json that we'll be working from for each post
        a number that corralates to table1
        text describing categories and content items for those categories
Table3 (cp_items): three columns - the details for an item
        the name of a content item
        the page number
        text describing that item.
Table4 (cp_styles): four columns - styles and layouts
        the type of style it is ("full", "section", "single", "block")
        the name of the style
        the page number
        text describing that style
Table5 (cp_types): two columns - what type of item each item is
        an item name
        the type of item it is (e.g. "character", "setting")

The commands to create these databases look like this:

CREATE TABLE IF NOT EXISTS cp_names ( URI VARCHAR(100) PRIMARY KEY, Page FLOAT(8.2) );
CREATE TABLE IF NOT EXISTS cp_contents ( Page FLOAT(8.2) PRIMARY KEY, Content MEDIUMTEXT );
CREATE TABLE IF NOT EXISTS cp_items ( Name VARCHAR(100), Page FLOAT(8.2), Description LONGTEXT, PRIMARY KEY ( Name, Page ) );
CREATE TABLE IF NOT EXISTS cp_styles ( Type TINYTEXT, Name VARCHAR(100), Page FLOAT(8.2), Description LONGTEXT, PRIMARY KEY ( Name, Page ) );
CREATE TABLE IF NOT EXISTS cp_types ( Name VARCHAR(100) PRIMARY KEY, Type TINYTEXT );

#=================#
#== Mysql Users ==#
#=================#

The script is designed to be used with two mysql users - one that only has SELECT privileges and one with all privileges in relation to the database created. The creation statements should look something like this:

CREATE USER 'cp_user'@'localhost' IDENTIFIED BY 'password123';
GRANT SELECT ON cp_database.* TO 'cp_user'@'localhost';
CREATE USER 'cp_user2'@'localhost' IDENTIFIED BY 'password456';
GRANT ALL PRIVILEGES ON cp_database.* TO 'cp_user2'@'localhost';
FLUSH PRIVILEGES;

The idea is that the config file will only have the username and password of the less privileged user, while the credentials for the more privileged user will not be stored on the server. This significantly reduces the likelihood of a malicious user modifying database contents without the owner's knowledge or permission.

#===================#
#== General Rules ==#
#===================#

* All styles and items MUST have internal names without spaces, given that the parsing is done based on whitespace

#=====================#
#== Types of Styles ==#
#=====================#

* full - This is the style that full character pages are built from. 
* section - This style focuses on individual sections of content in which items will be listed. So for example, a full page might have sections for "characters" and locations"; section styles will define what frames each of the individual items in those sections.
* single - This style is for pages displayed within the iframe showing only a single item. Think of them as a cross between full and section.
* block - This style is for blocks of content that are not expected to contain other items. For example, they might be used for a header or footer. These are called with the "block" command keyword. Note that there are a number of command keywords that can be used within block styles, but depending on where they're placed, they may not necessarily have the desired effect.
* item - Technically this is not a style. Items contain information about a specific item (relevant to a specific page) as well as text regarding that item.

#======================#
#== Command Keywords ==#
#======================#

Styles and, to some extent, items are created with HTML code. in order to get them to behave in the desired manner, this code is mixed in with command keywords that help determine what portions of the HTML should be output and in what way. All command keywords are prefaced by the string ">>>" with some amount of whitespace on either end. Other than the whitespace and the arguments descrived below nothing can come before or after them on the same line. 

Regular command kaywords:
* >>> var [VARIABLE] - a variable to be interpreted by the script
* >>> comment [TEXT] - a comment that won't be interpreted y the parser
* >>> link [ITEM NAME] - an item name to convert into a URL
* >>> ilink [ITEM NAME] [TEXT] - Convert this to a link that will be opened in the iframe
* >>> plink [TEXT] - Convert this to a link for the previous version of the current item
* >>> nlink [TEXT] - Convert this to a link for the next version of the current item (only on single item view)
* >>> content - the next level of content in the "full"->"section"->"item" chain, or the iframe for "full" styles that single pages will go into. (cannot be used in "block" styles)
* >>> block [STYLE NAME] - used to call a block style.
* >>> no_new_line - prevents the output from the previous line ending in a new line character. Useful for some spacing weirdness
* >>> set [NUMBER] - allows a usert to associate a number with a string and then later use the "SET" variable to recall that string.

Indicate start or end positions
* >>> repeat ["start" OR "end"] - (only in "section" and "full") Everything in between repeats for each section or item (if multiple starts are present before an end, they will be used in sequence and loop until all sections or items have been used) (cannot be used in "block" styles)
* >>> not_first ["start" OR "end"] - (only in "section", "full", and "block") Apply this to all items but the first
* >>> not_last ["start" OR "end"] - (only in  "section", "full", and "block") Apply this to all items but the last
* >>> is_first ["start" OR "end"] - (only in "section", "full", and "block") Apply this only to the first item
* >>> is_last ["start" OR "end"] - (only in  "section", "full", and "block") Apply this only to the last item
* >>> is_prev ["start" OR "end"] - (only in "single", "section", and "block") data that only appears if there's a previous item
* >>> is_next ["start" OR "end"] - (only in "single" and "block") data that only appears if there's a next item
* >>> no_prev ["start" OR "end"] - (only in "single", "section", and "block") data that only appears if there is no previous item
* >>> no_next ["start" OR "end"] - (only in "single" and "block") data that only appears if there is no next item
* >>> is_int_prev ["start" OR "end"] - (only in "full" or "block) data that only appears if there's a previous internal page
* >>> is_int_next ["start" OR "end"] - (only in "full" or "block) data that only appears if there's a next internal page
* >>> not_int_prev ["start" OR "end"] - (only in "full" or "block) data that only appears if there's no previous internal page
* >>> not_int_next ["start" OR "end"] - (only in "full" or "block) data that only appears if there's no next internal page
* >>> head ["start" OR "end"] - indicates a section that goes into the header
* >>> iframe ["start" OR "end"] - indicates a section that goes into the div that surrounds the iframe

Special data for items (must be listed before anything else):
* >>> disp_name - (only for items) The display name of the item
* >>> disp_image - (only for items) The image url for an item
* >>> item_data - (only for items) a varaible that can be used to store data about the item. Multiple of these can be used; they will be stored in an array
* >>> description ["start" OR "end"] - indicates the description for an item

Special data for full page styles:
* >>> single [STYLE NAME] - declare the single image style that should be used for the iframe

Special data for "content":
* >>> style - the style for the page (should be declared before any styles or items)
* >>> s_name - the name of the upcoming section (should be declared before the style) (There's no reason that this cannot contain any length of text or html)
* >>> s_style - the style of the upcoming section
* >>> item - an item within the section

Plain HTML and other information:
* Anything that needs to be parsed as plain html doesn't need to be preceeded with anything
* In "full" styles, the "content" call is where the script will request the content for the upcoming section, so if you plan to have sections, "content" NEEDS to be present.
* In "section" styles, the "repeat" call is when the script will request the content for the next item, so if you plan to have items, "repeat" NEEDS to be present - even if you know that there will only be one item.

Note: Other than the following exceptions, all lines beginning with ">>>" will be surrounded by new-line characters in the output html:
* var
* link

#==========================#
#== Declaration Keywords ==#
#==========================#

The script can import the contents of text files into the database. For this process, what kind of internal object (style, name, content, item, or type) as well as some other data will need to be specified. Declaration keywords are used to provide this information. All declaration keywords are prefaced by the string ">>>>>" with some amount of whitespace on either end. Other than the whitespace and the arguments descrived below nothing can come before or after them on the same line.

Creation:
* >>>>> declare name [URL] [PAGE]
* >>>>> declare content [PAGE]
* >>>>> declare style [NAME] [PAGE] [TYPE]
* >>>>> declare item [NAME] [PAGE]
* >>>>> declare type [NAME] [TYPE]

Deletion:
* >>>>> delete name [URL]
* >>>>> delete content [PAGE]
* >>>>> delete style [NAME] [PAGE]
* >>>>> delete item [NAME] [PAGE]
* >>>>> delete type [NAME]

#========================#
#== Internal Variables ==#
#========================#

These are variables that can be used with the command keyword "var":

* ITEM_NAME - The name used internally to reference this item
* DISP_NAME - The display name of an item (note, there's no rreason why this cannot contain html)
* IMAGE - the image url for an item. These should be relative to the directory where index.php is located.
* ITEM_DATA [NUMBER (starting with 1)] - Other data for the item, stored as an array. So, for example, if you want to have a variable for the age of characters.
* SECTION_NAME - the display name of a section (note, there's no rreason why this cannot contain html)
* SOURCE_URL - the URL of the source page that this page is referencing
* MAIN_URL - the URL for the main page of this site (not the source site)
* SECT_NUM - the number of the current section (counting starts at zero)
* ITEM_NUM - The number of the current item in the current section (counting starts at zero)
* NEXT_INT_PAGE - (Not available for single styles) the URL of the next internal page
* PREV_INT_PAGE -  (Not available for single styles) the URL of the previous internal page
* SET [NUMBER] - a variable set by the user using the "set" command keyword

#===================#
#== Project Files ==#
#===================#

Files that are included within the project:

* index.php - Calls the other files for the script
* initialize.php - creates the necessary mysql tables (assuming that there is already a mysql user and database, and that the config file is filled out)
* import.php - A page that allows the user to import content into the database
* export.php - Outputs the text for all of the items, types, names, contents, and styles within the database.
* includes/config.php - Includes the configuration to connect to the database as well as specifics about the site in question
* includes/parse.php - Includes the functions necessaey to parse the contents, items, and styles
* includes/url.php - Parses the url and other data to determine what content needs to be loaded
* includes/full.php - Loads a full page relative to a post from the source page
* includes/connect.php - connects to mysql
* includes/single.php - Loads a siingle page view
* includes/js_top_full.txt - text that will be used to begin the full page view pages
* includes/js_bottom_full.txt - additional text for the full page view pages containing the javascript that makes the links work
* includes/parse2.php - Includes the functions necessaary to parse database content

#===============================#
#== Internally Generated HTML ==#
#===============================#

There are four major pieces of HTML that are generated by the code within the project. All other HTML will need to be within styles and items.

* The following tags will be added programatically <html>, <head>, </head>, </body>, </html>. Note that the opening <body> tag is expected to be within styles.
* The script will create the "next" and "previous" links for items based on command keywords within style (more information below)
* The script will create the iframe element for single item pages based on the "content" command keyword within "iframe start" and "iframe end" command keywords within the style (more information below)
* The script will output initial css and javascript content based on the text within the files js_top_full.txt and js_bottom_full.txt

#=====================#
#== Regarding Links ==#
#=====================#

Any links generated by the script within the full page view will have the html class "cp_link". They will be presented in the following format:

	<a class="cp_link" href="#" src="" onclick="fn_open_link(this);return false;">link text</a>

where the value for "src" will be populated with the URL of the single item view. They will still have the same class within the single item view, but they will look like this instead:

	<a class="cp_link" href="">link text</a>

where the "href" attribute will be populated with the URL.

#==========================#
#== Regarding the Iframe ==#
#==========================#

The iframe containing the single item view will be put in place with the ">>> content" indicator after beginning an ">>> iframe start" block. It will have the id "cp_single" and will be in this format:

	<iframe id="cp_single" src=""></iframe>

and the "src" attribute will be populated by javascript as needed.






