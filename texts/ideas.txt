1)  Modify the single-item view so that it loads next and previous pages in the background before displaying them?
2)  Cookies and session data? <- maybe storing the highest seen current page in the session data and not letting the next and previous links for full pages extend beyond that?
3)  A page that lists all items of a certain type at the current point in the story. (or maybe shows 25 at a time?)
	1)  The url for this needs to be in the following format: /lists/[TYPE NAME]/[PAGE NUMBER] - example: /lists/characters/40
	2)  There needs to be a constant in the config for "lists" the same way that there's a variable for "pages".
4)  html for confusing lines is parsed in import.php - I need to make it so that it's not parsed.
5)  In fn_parse_descriptions, I should comment what each of the variables does. 'cause there are a lot of 'em.
6)  Links to the source
	1)  The main page
	2)  The source page with a specific URI
	3)  Should this automatically open in a new tab? In the single item iframe? In a DIFFERENT iframe?
7)  Revise how content is done entirely (see below).
	1)  Allow for "block" content, similar to block styles
	2)  Allow for a header and footer similar to the description of items
	3)  Allow a keyword in each section that identifies a corrleating item type
	4)  Pull item rows when parsing the content object and then make those rows PART OF the content object.
8)  A command keyword to create a link to the relevant list
9)  each section within content should have an internal name. The content block should have a keyword that lists off those names in the order that they'll go in (see below)
10) Go through all the #####

--- Additional variables that I need to make
* SECTION_HEAD - the parsed content of the section header
* SECTION_FOOT - the parsed content of the section footer
* LIST_URL - the URL for the list of this type
* SOURCE_URI [URI] - creates a URL in the format of: PROTOCOL . "://" . REFERER_BASE . [THE URI PROVIDED]

--- example of new content formatting

>>>>> declare content 5 page
>>> style style1_full
>>> sections characters settings art_styles
>>> section characters
>>> type character
>>> s_name Characters
>>> s_style style1_section
>>> items bina gregor
>>> header start
Header text
>>> header end
>>> footer start
Footer text
>>> footer end
>>> section settings
>>> type setting
>>> s_name Settings
>>> s_style style1_section
>>> items laundry
>>> header start
Header text
>>> header end
>>> footer start
Footer text
>>> footer end
>>> section art_styles
>>> type art_styles
>>> s_name Art Styles
>>> s_style style1_section
>>> items pixelated
>>> header start
Header text
>>> header end
>>> footer start
Footer text
>>> footer end

--- the above can be condensed to the following:

>>>>> declare content 5 page
>>> style style1_full
>>> sections characters settings art_styles
>>> section characters
>>> type character
>>> s_name Characters
>>> s_style style1_section
>>> items bina gregor
>>> block head_foot

>>>>> declare content 5 block head_foot
>>> header start
Header text
>>> header end
>>> footer start
Footer text
>>> footer end

>>>>> declare content 5 block setting_art
>>> section settings
>>> type setting
>>> s_name Settings
>>> s_style style1_section
>>> items laundry
>>> block head_foot
>>> section art_styles
>>> type art_style
>>> s_name Art Styles
>>> s_style style1_section
>>> items pixelated
>>> block head_foot

--- Description of the process that will be used to parse this

1) Go through the page content creating a list of items and expanding each block as they arrive. The output of this step should be an array of items and an array of lines (minus the block lines)
2) Query the database for all of the requested items, create an object out of them
3) Parse through the fully expanded content, parsing headers and footers as necessary in order to create a JSON object.

--- the object containing all of the items will look like this

{
	bina:{
		"name":"bina",
		"page":2,
		"next":10,
		"previous":NULL,
		"description":"[THE FULL, UNPARSED ITEM DESCRIPTION]"
	},
	gregor:{
		"name":"gregor",
		"page":2,
		"next":10,
		"previous":NULL,
		"description":"[THE FULL, UNPARSED ITEM DESCRIPTION]"
	},
	laundry:{

		"name":"laundry",
		"page":2,
		"next":10,
		"previous":NULL,
		"description":"[THE FULL, UNPARSED ITEM DESCRIPTION]"
	},
	pixelated:{
		"name":"pixelated",
		"page":2,
		"next":10,
		"previous":NULL,
		"description":"[THE FULL, UNPARSED ITEM DESCRIPTION]"
	}
}

--- the final content object would look like this:

{
	"style":"style1_full",
	"sections":[
		{
			"id":"characters",
			"type":"character",
			"name":"Characters",
			"style":"style1_section",
			"header":"[THE FULL, UNPARSED HEADER TEXT]",
			"footer":"[THE FULL, UNPARSED FOOTER TEXT]",
			"items":[
				{
					"name":"bina",
					"page":2,
					"next":10,
					"previous":NULL,
					"description":"[THE FULL, UNPARSED ITEM DESCRIPTION]"
				},
				{
					"name":"gregor",
					"page":2,
					"next":10,
					"previous":NULL,
					"description":"[THE FULL, UNPARSED ITEM DESCRIPTION]"
				}
			]
		},
		{
			"id":"settings",
			"type":"setting",
			"name":"Settings",
			"style":"style1_section",
			"header":"[THE FULL, UNPARSED HEADER TEXT]",
			"footer":"[THE FULL, UNPARSED FOOTER TEXT]",
			"items":[
				{
					"name":"laundry",
					"page":2,
					"next":10,
					"previous":NULL,
					"description":"[THE FULL, UNPARSED ITEM DESCRIPTION]"
				}
			]
		},
		{
			"id":"art_styles",
			"type":"art_style",
			"name":"Art Styles",
			"style":"style1_section",
			"header":"[THE FULL, UNPARSED HEADER TEXT]",
			"footer":"[THE FULL, UNPARSED FOOTER TEXT]",
			"items":[
				{
					"name":"pixelated",
					"page":2,
					"next":10,
					"previous":NULL,
					"description":"[THE FULL, UNPARSED ITEM DESCRIPTION]"
				}
			]
		}
	]
}

--- Command keywords for content

* >>> style [FULL STYLE NAME] - declares the "full" style for this content
* >>> sections [LIST OF SPACE SEPARATED SECTION ID's] - the list of the sections in the order that they will go in
* >>> section [SECTION ID] - an identifier for the section. Note that this won't be displayed and as such can be arbitrary, so long as none are repeated
* >>> type [TYPE] - The items listed in this section will correlate to a type per the cp_types table
* >>> s_name [STRING] - a display name for the section, referenced with the "SECTION_NAME" variable
* >>> s_style [SECTION STYLE NAME] - the name of the style that will be used for the section
* >>> items [LIST OF SPACE SEPARATED ITEMS] - the list of the items that will appear in this section, in the order that they will go in.
* >>> block [BLOCK NAME] - The name of a content block. This line will be replaced by all lines within that content block
* >>> header ["start" OR "end"] - everything within these tags will be interpreted by the style parser rather thant he content parser. Called by the "SECTION_HEAD" variable
* >>> footer ["start" OR "end"] - everything within these tags will be interpreted by the style parser rather thant he content parser. Called by the "SECTION_FOOT" variable









